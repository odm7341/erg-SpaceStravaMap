{"id":"odm7341_MapWidgetStrava","name":"Map Strava","description":"Map based on open layer, and exporting .gpx files for strava","version":"1.3","author":"Tijmen van Gulik & Owen McClure","url":"https://raw.githubusercontent.com/odm7341/erg-SpaceStravaMap/main/stravaMap.json","script":"/**\r\n * Created by tijmen on 23-12-15.\r\n *\r\n * modified by odm7341 16-01-22\r\n */\r\nvar odm7341_MapWidgetStrava;\r\n(function (odm7341_MapWidgetStrava) {\r\n    const EPG_MAP = 'EPSG:3857';\r\n    const EPG_KML = 'EPSG:4326';\r\n    /*------------------------------------------------------------------------------\r\n     Simple google earth widget example\r\n     ------------------------------------------------------------------------------*/\r\n    class MapWidgetStrava extends ergometerWidgets.ErgometerWidget {\r\n        constructor(controller) {\r\n            super(controller);\r\n            this._track = [];\r\n            this._trackIndex = 0;\r\n            this._kmlData = null;\r\n            this._rowingZoom = 17;\r\n            this._trainingDistance = 0;\r\n            this._workDistance = 0;\r\n            this._updateDelay = 1000 / 20; //20 frames per second\r\n            this._animating = false;\r\n            this._waitingForTimeout = false;\r\n            this._speed = 0;\r\n            this._finished = false;\r\n            this.caption = \"Map widget example\";\r\n            this.editPropertiesVisible = true;\r\n            this.defaultHeight = 6;\r\n            this._track = [];\r\n            this._gpxData = [];\r\n        }\r\n        flyToStart(done, duration = 2000) {\r\n            if (this._track && this._track.length > 0) {\r\n                var trackPoint = this._track[0];\r\n                var currentZoom = this._map.getView().getZoom();\r\n                this.flyTo([trackPoint.longitude, trackPoint.latitude, 0], this._rowingZoom, trackPoint.heading, currentZoom - 1, duration, (complete) => {\r\n                    this._animatedDistance = 0;\r\n                    // start it off\r\n                    this._trackIndex = 0;\r\n                    done();\r\n                    return true;\r\n                });\r\n            }\r\n        }\r\n        startAnimation() {\r\n            if (!this._animating) {\r\n                this._animating = true;\r\n                var doStart = () => {\r\n                    this._animatedDistance = 0;\r\n                    this._trackIndex = 0;\r\n                    this._map.on('postcompose', this.tickAnimation.bind(this));\r\n                    this._map.render();\r\n                };\r\n                doStart();\r\n                if (this._animatedDistance == 0)\r\n                    doStart();\r\n                else\r\n                    this.flyToStart(doStart, 0);\r\n                //               \r\n            }\r\n        }\r\n        stopAnimation() {\r\n            if (this._animating) {\r\n                this._animating = false;\r\n                this._workDistance = 0;\r\n                this._trainingDistance = 0;\r\n                this._map.un('postcompose', this.tickAnimation);\r\n                this.showWholeMap();\r\n            }\r\n            this._trackIndex = 0;\r\n        }\r\n        tickAnimation(event) {\r\n            if (this._animating) {\r\n                var vectorContext = event.vectorContext;\r\n                var currentTime = new Date().getTime();\r\n                var timeSinceLastUpdate = 0;\r\n                if (this._lastUpdateTime) {\r\n                    timeSinceLastUpdate = currentTime - this._lastUpdateTime;\r\n                }\r\n                var extrapolatedDistance = 0;\r\n                if (this._speed && !this._finished) {\r\n                    extrapolatedDistance = (this._speed * (timeSinceLastUpdate / 1000));\r\n                }\r\n                var totalDistanceCalc = this._workDistance + extrapolatedDistance;\r\n                //take the next track item when moving past the current\r\n                var currentTrackItem = this._track[this._trackIndex];\r\n                while (this._trackIndex < this._track.length - 1 && totalDistanceCalc >= currentTrackItem.cumualtiveDistance + currentTrackItem.distance) {\r\n                    this._trackIndex++;\r\n                    currentTrackItem = this._track[this._trackIndex];\r\n                    this._animatedDistance = 0.0000001;\r\n                }\r\n                var heading = currentTrackItem.heading;\r\n                //calc the relative positon within the current track line\r\n                var relativeDistance = totalDistanceCalc - currentTrackItem.cumualtiveDistance;\r\n                if (relativeDistance < 0) //do not go backwards\r\n                    relativeDistance = 0.0000001;\r\n                //calc the next coordinate\r\n                var dest = this.calcNextCoordinate(currentTrackItem.latitude, currentTrackItem.longitude, relativeDistance, heading);\r\n                // calc next coord 2\r\n                //var dest = this.calcNextCoord2(currentTrackItem.latitude, currentTrackItem.longitude, relativeDistance, heading);\r\n                if (this._animatedDistance < relativeDistance) { //only update the rower location if there is forward movement\r\n                    this._animatedDistance = relativeDistance;\r\n                    var rower_location = ol.proj.fromLonLat([dest.longitude, dest.latitude]);\r\n                    this._long = dest.longitude;\r\n                    this._lat = dest.latitude;\r\n                    var view = this._map.getView();\r\n                    view.setCenter(rower_location);\r\n                    view.setRotation(this.calc_rotation(heading));\r\n                    //console.log(this._rowingZoom)\r\n                    var rowerPoint = new ol.geom.Point(rower_location);\r\n                    this._rower.setGeometry(rowerPoint);\r\n                }\r\n                else {\r\n                    //console.log(this._animatedDistance - relativeDistance)\r\n                }\r\n                //vectorContext.drawFeature(this._rower, this._styles.rower);\r\n                //var feature = new ol.Feature(rower_location);\r\n                //vectorContext.drawFeature(feature, this._styles.rower);\r\n                /*\r\n                console.log({\r\n                  long :dest.longitude,\r\n                  lat: dest.latitude,\r\n                  dist: this._workDistance,\r\n                  rotation: heading\r\n                });\r\n                */\r\n                this._map.render();\r\n            }\r\n        }\r\n        /* Helper functions, courtesy of\r\n         http://www.movable-type.co.uk/scripts/latlong.html */\r\n        calcDistance(lat1, lng1, lat2, lng2) {\r\n            var a = Math.sin(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180);\r\n            var b = Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\r\n                Math.cos((lng2 - lng1) * Math.PI / 180);\r\n            return 6371000 * Math.acos(a + b);\r\n        }\r\n        calc_rotation(heading) {\r\n            return (360 - heading) / 360 * Math.PI * 2;\r\n        }\r\n        radians(n) {\r\n            return n * (Math.PI / 180);\r\n        }\r\n        degrees(n) {\r\n            return n * (180 / Math.PI);\r\n        }\r\n        calcHeading(startLat, startLong, endLat, endLong) {\r\n            startLat = this.radians(startLat);\r\n            startLong = this.radians(startLong);\r\n            endLat = this.radians(endLat);\r\n            endLong = this.radians(endLong);\r\n            var dLong = endLong - startLong;\r\n            var dPhi = Math.log(Math.tan(endLat / 2.0 + Math.PI / 4.0) / Math.tan(startLat / 2.0 + Math.PI / 4.0));\r\n            if (Math.abs(dLong) > Math.PI) {\r\n                if (dLong > 0.0)\r\n                    dLong = -(2.0 * Math.PI - dLong);\r\n                else\r\n                    dLong = (2.0 * Math.PI + dLong);\r\n            }\r\n            return (this.degrees(Math.atan2(dLong, dPhi)) + 360.0) % 360.0;\r\n        }\r\n        calcNextCoord2(lat1, lon1, dist, brng) {\r\n            var a = 6378137, b = 6356752.3142, f = 1 / 298.257223563, // WGS-84 ellipsiod\r\n            s = dist, alpha1 = this.radians(brng), sinAlpha1 = Math.sin(alpha1), cosAlpha1 = Math.cos(alpha1), tanU1 = (1 - f) * Math.tan(this.radians(lat1)), cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1 * cosU1, sigma1 = Math.atan2(tanU1, cosAlpha1), sinAlpha = cosU1 * sinAlpha1, cosSqAlpha = 1 - sinAlpha * sinAlpha, uSq = cosSqAlpha * (a * a - b * b) / (b * b), A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))), B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))), sigma = s / (b * A), sigmaP = 2 * Math.PI;\r\n            while (Math.abs(sigma - sigmaP) > 1e-12) {\r\n                var cos2SigmaM = Math.cos(2 * sigma1 + sigma), sinSigma = Math.sin(sigma), cosSigma = Math.cos(sigma), deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\r\n                sigmaP = sigma;\r\n                sigma = s / (b * A) + deltaSigma;\r\n            }\r\n            ;\r\n            var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1, lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp)), lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1), C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha)), L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM))), revAz = Math.atan2(sinAlpha, -tmp); // final bearing\r\n            return {\r\n                latitude: this.degrees(lat2),\r\n                longitude: lon1 + this.degrees(L)\r\n            };\r\n        }\r\n        calcNextCoordinate(lat, lng, dist, heading) {\r\n            lat *= Math.PI / 180;\r\n            lng *= Math.PI / 180;\r\n            heading *= Math.PI / 180;\r\n            dist /= 6371000; // angular dist\r\n            var lat2 = Math.asin(Math.sin(lat) * Math.cos(dist) +\r\n                Math.cos(lat) * Math.sin(dist) * Math.cos(heading));\r\n            return {\r\n                latitude: 180 / Math.PI * lat2,\r\n                longitude: 180 / Math.PI *\r\n                    (lng + Math.atan2(Math.sin(heading) * Math.sin(dist) * Math.cos(lat2), Math.cos(dist) - Math.sin(lat) * Math.sin(lat2)))\r\n            };\r\n        }\r\n        initControl() {\r\n            super.initControl();\r\n            //make a canvas element within the div of the Erogmeter widget\r\n            var mapId = this.name + \"Map2d\";\r\n            this.$container.append(\" <div id='\" + mapId + \"' class='StravaMapContainer'></div>\");\r\n            this._$map = $(\"#\" + mapId);\r\n            this.loadMapState();\r\n            this.initMap();\r\n            var self = this;\r\n            this._dialogMapSettings = dialog.newStandardDialog({\r\n                title: 'Map settings',\r\n                message: $('#dialogMapStravaSettings'),\r\n                buttons: [{\r\n                        label: 'Export',\r\n                        action: (dlg) => {\r\n                            this.makeGpxString();\r\n                        }\r\n                    }],\r\n                onhide: () => {\r\n                    this.updateSettings();\r\n                }\r\n            });\r\n            $('#mapStravaLoadFile').css(\"visibility\", \"hidden\");\r\n            $('#mapStravaLoadFileButton').click(function (e) {\r\n                e.preventDefault();\r\n                $('#mapStravaLoadFile').trigger('click');\r\n            });\r\n            //$('#mapStravaExportFileButton').on(\"click\", this.makeGpxString());\r\n            /*\r\n            var sld = $(\"#MapStravaZoom\").slider()\r\n                                //.on('slide', this.updateSettings)\r\n                                .data('value', this._rowingZoom);\r\n            */\r\n            $(\"#mapStravaLoadFile\").change(function (evt) {\r\n                var files = evt.target.files;\r\n                for (var i = 0; i < files.length; i++) {\r\n                    var file = files[i];\r\n                    var reader = new FileReader();\r\n                    reader.onload = function (e) {\r\n                        try {\r\n                            self.loadFromKmlData(e.target.result);\r\n                        }\r\n                        catch (err) {\r\n                            app.showTopError(\"Can not read plugin: \" + err);\r\n                            throw err;\r\n                        }\r\n                    };\r\n                    reader.readAsText(file);\r\n                }\r\n            });\r\n        }\r\n        flyTo(locationParm, destZoom, heading, aboveZoom, duration, done) {\r\n            var location = ol.proj.fromLonLat(locationParm);\r\n            var view = this._map.getView();\r\n            var zoom = view.getZoom();\r\n            if (!aboveZoom)\r\n                aboveZoom = zoom;\r\n            if (!destZoom)\r\n                destZoom = zoom;\r\n            var parts = 2;\r\n            var called = false;\r\n            function callback(complete) {\r\n                --parts;\r\n                if (called) {\r\n                    return;\r\n                }\r\n                if (parts === 0 || !complete) {\r\n                    called = true;\r\n                    done(complete);\r\n                }\r\n            }\r\n            view.animate({\r\n                center: location,\r\n                duration: duration\r\n            }, callback);\r\n            view.animate({\r\n                zoom: aboveZoom,\r\n                duration: duration / 2\r\n            }, {\r\n                zoom: destZoom,\r\n                duration: duration / 2,\r\n                rotation: this.calc_rotation(heading)\r\n            }, callback);\r\n        }\r\n        showWholeMap() {\r\n            this._map.getView().fit(this._trackExtent, this._map.getSize());\r\n        }\r\n        trackLoaded() {\r\n            this.showWholeMap();\r\n            this._trackIndex = 0;\r\n            this._animatedDistance = -1;\r\n            var trackPoint = this._track[this._trackIndex];\r\n            var rowerPoint = new ol.geom.Point(ol.proj.fromLonLat([trackPoint.longitude, trackPoint.latitude, 0]));\r\n            this._rower.setGeometry(rowerPoint);\r\n        }\r\n        setLoadTracEvent() {\r\n            var self = this;\r\n            this._raceLayer.once('change', function (evt) {\r\n                try {\r\n                    var src = this.getSource();\r\n                    if (src.getState() == 'ready') {\r\n                        var features = src.getFeatures();\r\n                        if (typeof features === 'undefined' || !features || features.length == 0)\r\n                            throw 'No features in KML file';\r\n                        var geometry = features[0].getGeometry();\r\n                        if (typeof geometry === 'undefined' || !geometry || geometry.length == 0)\r\n                            throw 'No geometry found in KML file';\r\n                        var coordinates = geometry.getCoordinates();\r\n                        if (typeof coordinates === 'undefined' || !coordinates || coordinates.length == 0)\r\n                            throw 'No coordinates found in KML file';\r\n                        self._trackExtent = geometry.getExtent();\r\n                        self._track = [];\r\n                        var cumualtiveDistance = 0;\r\n                        for (var i = 0; i < coordinates.length - 2; i++) {\r\n                            var srcCoor = ol.proj.toLonLat(coordinates[i]);\r\n                            var nextCoor = ol.proj.toLonLat(coordinates[i + 1]);\r\n                            var distance = self.calcDistance(srcCoor[1], srcCoor[0], nextCoor[1], nextCoor[0]);\r\n                            var heading = self.calcHeading(srcCoor[1], srcCoor[0], nextCoor[1], nextCoor[0]);\r\n                            self._track.push({\r\n                                longitude: srcCoor[0],\r\n                                latitude: srcCoor[1],\r\n                                distance: distance,\r\n                                cumualtiveDistance: cumualtiveDistance,\r\n                                heading: heading\r\n                            });\r\n                            cumualtiveDistance += distance;\r\n                        }\r\n                        if (self._track.length > 0)\r\n                            self.trackLoaded();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    this._kmlData = null;\r\n                    app.showTopError(e);\r\n                }\r\n            });\r\n        }\r\n        initMap() {\r\n            //require([\"https://openlayers.org/en/v3.20.1/build/ol.js\"],\r\n            //   (ola) => {\r\n            //     ol=ola;\r\n            var self = this;\r\n            var url = 'TheBoatRace.kml';\r\n            //'http://www.vangulik.org/Ergometer/TheBoatRace.kml'\r\n            var projection = ol.proj.get(EPG_MAP);\r\n            var mapLayer = new ol.layer.Tile({ source: new ol.source.OSM() });\r\n            this._styles = {\r\n                'rower': new ol.style.Style({\r\n                    image: new ol.style.Icon({\r\n                        anchor: [0.5, 0.5],\r\n                        src: 'images/LogoBW22.png'\r\n                    })\r\n                })\r\n            };\r\n            this._rower = new ol.Feature({\r\n                type: 'rower',\r\n                geometry: new ol.geom.Point(ol.proj.fromLonLat([-0.212708093427223, 51.46670252304421, 0]))\r\n            });\r\n            var rowerLayer = new ol.layer.Vector({\r\n                source: new ol.source.Vector({\r\n                    features: [this._rower]\r\n                }),\r\n                style: function (feature) {\r\n                    // hide geoMarker if animation is active\r\n                    return self._styles[feature.get('type')];\r\n                }\r\n            });\r\n            if (this._kmlData) {\r\n                this._raceLayer = new ol.layer.Vector();\r\n            }\r\n            else {\r\n                this._mapName = 'The boat race';\r\n                this._raceLayer = new ol.layer.Vector({\r\n                    source: new ol.source.Vector({\r\n                        url: url,\r\n                        format: new ol.format.KML(),\r\n                    })\r\n                });\r\n            }\r\n            this.setLoadTracEvent();\r\n            this._map = new ol.Map({\r\n                layers: [mapLayer, this._raceLayer, rowerLayer],\r\n                target: this._$map.get(0),\r\n                view: new ol.View({\r\n                    center: ol.proj.fromLonLat([-0.212708093427223, 51.46670252304421]),\r\n                    zoom: 1,\r\n                    projection: projection\r\n                }),\r\n                controls: []\r\n            });\r\n            if (this._kmlData) {\r\n                this.setRaceLayerFromKmlData();\r\n            }\r\n            //   });\r\n        }\r\n        resize() {\r\n            super.resize();\r\n            this._$map.css({ height: (this.$container.innerHeight() - 24).toString() + \"px\" });\r\n            if (this._map)\r\n                this._map.updateSize();\r\n        }\r\n        strokeDataUpdate(strokeData) {\r\n            //this._workDistance = strokeData.distance + this._lastWorkTime;\r\n            this._workDistance = strokeData.distance;\r\n            this._speed = strokeData.speed;\r\n            this._lastUpdateTime = new Date().getTime();\r\n            if (!this._finished && this._speed && this._speed > 0) {\r\n                if (!this._animating) {\r\n                    this.startAnimation();\r\n                }\r\n            }\r\n            else\r\n                this.stopAnimation();\r\n            // store the locations and time to an array for gpx export\r\n            //console.log(this._gpxData.length)\r\n            if (this._long) {\r\n                //console.log([this._long, this._lat, this._lastUpdateTime])\r\n                this._gpxData.push([this._long, this._lat, this._lastUpdateTime]);\r\n            }\r\n        }\r\n        trainingDataUpdate(trainingData) {\r\n            if (this._trainingDistance != trainingData.distance) {\r\n                this._trainingDistance = trainingData.distance;\r\n                //get a new high score for the training distance\r\n                if (trainingData.distance > 0 && this._workDistance == 0 && !this._animating)\r\n                    this.flyToStart(() => { });\r\n            }\r\n            var finished = (trainingData.endDistance > 0 && trainingData.endDuration > 0);\r\n            if (finished != this._finished) {\r\n                this._finished = finished;\r\n                if (this._finished) {\r\n                    this.stopAnimation();\r\n                    //this._lastWorkTime= this._lastWorkTime+ trainingData.endDistance;\r\n                }\r\n            }\r\n            //this._gpxString = this.makeGpxString()\r\n        }\r\n        makeGpxString() {\r\n            let result = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><gpx version=\"1.0\"><name>Example gpx</name><desc>made with js</desc><trk><name>Test Row</name><number>1</number><trkseg>';\r\n            var arrayLength = this._gpxData.length;\r\n            for (var i = 0; i < arrayLength; i++) {\r\n                var ts = new Date(this._gpxData[i][2]).toISOString();\r\n                result += '<trkpt lat=\"' + this._gpxData[i][1] + '\" lon=\"' + this._gpxData[i][0] + '\"><ele>2376</ele><time>' + ts + '</time></trkpt>';\r\n            }\r\n            result += '</trkseg></trk></gpx>';\r\n            var blob;\r\n            blob = new Blob([result], {\r\n                type: \"data:text/xml;charset=utf-8\"\r\n            });\r\n            utilities.writeFile(blob, \"Workout.GPX\");\r\n            //return result\r\n        }\r\n        earthInitialized() {\r\n            console.log(\"Hello\");\r\n        }\r\n        loaded() {\r\n            super.loaded();\r\n            pm3.monitor.pubsubs.subStrokeDataUpdate(this, this.strokeDataUpdate);\r\n            pm3.monitor.pubsubs.subTrainingDataUpdate(this, this.trainingDataUpdate);\r\n        }\r\n        beforeUnload() {\r\n            super.beforeUnload();\r\n            pm3.monitor.pubsubs.unsubStrokeDataUpdate(this, this.strokeDataUpdate);\r\n            pm3.monitor.pubsubs.unsubTrainingDataUpdate(this, this.trainingDataUpdate);\r\n        }\r\n        setRaceLayerFromKmlData() {\r\n            var kml = new ol.format.KML();\r\n            var src = new ol.source.Vector();\r\n            var features = kml.readFeatures(this._kmlData, { dataProjection: EPG_KML, featureProjection: EPG_MAP });\r\n            this._mapName = kml.readName(this._kmlData);\r\n            src.addFeatures(features);\r\n            this._raceLayer.setSource(src);\r\n        }\r\n        loadFromKmlData(kmlData) {\r\n            this.setLoadTracEvent();\r\n            this._kmlData = kmlData;\r\n            this.setRaceLayerFromKmlData();\r\n            //var src = this._raceLayer.getSource();\r\n            //src.clear();\r\n            //src.addFeatures(features);\r\n            //this._map.getView().fit(this._raceLayer.getExtent(),this._map.getSize());\r\n        }\r\n        openEditProperties() {\r\n            $('#stravaMapName').text(this._mapName);\r\n            $('#stravaMapDistance').text(' (' + this.getTrackDistance().toString() + 'm ) ');\r\n            $('#MapStravaZoomValue').text(this._rowingZoom.toString());\r\n            $(\"#MapStravaZoom\").val(this._rowingZoom.toString()),\r\n                $(\"#MapStravaZoom\").slider({\r\n                    value: this._rowingZoom\r\n                }),\r\n                this._dialogMapSettings.open();\r\n        }\r\n        updateSettings() {\r\n            var newZoom = parseInt($('#MapStravaZoom').val());\r\n            console.log(newZoom);\r\n            newZoom != this._rowingZoom && (this._rowingZoom = newZoom,\r\n                this._animating || this.flyToStart(function () { }));\r\n            this.saveMapState();\r\n        }\r\n        getMapSettings() {\r\n            return { kmlData: this._kmlData,\r\n                rowingZoom: this._rowingZoom\r\n            };\r\n        }\r\n        setMapSettings(settings) {\r\n            this._kmlData = settings.kmlData;\r\n            this._rowingZoom = settings.rowingZoom || 17;\r\n        }\r\n        saveMapState() {\r\n            localStorage.setItem(\"MapExampleWidget_settings\", JSON.stringify(this.getMapSettings()));\r\n        }\r\n        loadMapState() {\r\n            var settingsString = localStorage.getItem(\"MapExampleWidget_settings\");\r\n            var settings;\r\n            if (settingsString != \"undefined\" && settingsString != null && settingsString != \"null\") {\r\n                settings = JSON.parse(settingsString);\r\n                this.setMapSettings(settings);\r\n            }\r\n        }\r\n        getTrackDistance() {\r\n            if (this._track && this._track.length > 0)\r\n                return Math.round(this._track[this._track.length - 1].cumualtiveDistance);\r\n            else\r\n                return 0;\r\n        }\r\n    }\r\n    /*------------------------------------------------------------------------------\r\n     Create and remove the widgets in the Plugin\r\n     ------------------------------------------------------------------------------*/\r\n    class StravaPlugin extends ExternalPlugin {\r\n        init() {\r\n            //create the widget(s) on create\r\n            dashboard.widgetRegistry().register(MapWidgetStrava, 'odm7341_MapWidgetStrava', 'Strava Map', ['Other']);\r\n        }\r\n        remove() {\r\n            //remove the widgets when the plugin is removed\r\n            dashboard.widgetRegistry().deregister('odm7341_MapWidgetStrava');\r\n        }\r\n    }\r\n    var plugin;\r\n    plugin = new StravaPlugin();\r\n})(odm7341_MapWidgetStrava || (odm7341_MapWidgetStrava = {}));\r\n","styles":".StravaMapContainer {\n    padding-top: 20px;\n    padding-left: 4px;\n    padding-right: 4px;\n    padding-bottom:12px;\n}","typeScript":"/**\n * Created by tijmen on 23-12-15.\n * \n * modified by odm7341 16-01-22\n */\n\nmodule odm7341_MapWidgetStrava { //make a name space to prevent mix ups\n    \n\n    interface MapCoordinate {\n        longitude : number;\n        latitude : number;\n        altitude? : number;\n    }\n    interface TrackPoint {\n        longitude : number;\n        latitude : number;\n        distance : number;\n        cumualtiveDistance  : number;\n        heading : number;\n    }\n    interface MapSettings {\n        kmlData : string;\n        rowingZoom : number;\n    }\n    const EPG_MAP = 'EPSG:3857';\n    const EPG_KML = 'EPSG:4326';\n        \n    /*------------------------------------------------------------------------------\n     Simple google earth widget example\n     ------------------------------------------------------------------------------*/\n\n    class MapWidgetStrava  extends ergometerWidgets.ErgometerWidget {\n        private _trainingDistance : number;\n        private _workDistance : number;\n        private _updateDelay : number;\n        private _animating : boolean;\n        private _waitingForTimeout : boolean;\n        private _speed : number;\n        private _lastUpdateTime : number;\n        private _animatedDistance : number;\n        private _finished;\n        private _$map : JQuery;\n        private _track : TrackPoint[]=[];\n        private _trackIndex : number = 0;\n        //private _lastWorkTime =0; //used for debugging and going longer than 100 meters\n\n        private _map : ol.Map;\n        private _raceLayer : ol.layer.Vector;\n        private _trackExtent : number[];\n        private _rower : ol.Feature;\n        private _styles;\n        private _kmlData : string = null;\n        private _mapName : string;\n        private _rowingZoom = 17;\n        private _dialogMapSettings : BootstrapDialog;\n        private _gpxData : (number | Date)[][];\n        private _long : number;\n        private _lat : number;\n\n        public flyToStart(done : ()=>void, duration =2000 ) {\n            if ( this._track && this._track.length>0) {\n                var trackPoint=this._track[0];\n                var currentZoom = this._map.getView().getZoom();\n                this.flyTo([trackPoint.longitude,trackPoint.latitude,0 ],this._rowingZoom,\n                      trackPoint.heading,currentZoom-1,duration,(complete : boolean)=>{\n                        this._animatedDistance=0;\n                        // start it off\n                        this._trackIndex=0;\n                        done(); \n                        return true;                        \n                      } );\n\n            }\n        }\n        public startAnimation() {\n            if (!this._animating) {\n                this._animating=true;\n                var doStart= ()=> {\n                    this._animatedDistance=0;\n                    this._trackIndex=0;\n                    this._map.on('postcompose', this.tickAnimation.bind(this));\n                    this._map.render();\n         \n                }\n                doStart();\n                \n                if (this._animatedDistance==0) \n                   doStart();\n                 else this.flyToStart( doStart,0); \n                \n                \n                //               \n            }\n\n             \n        }\n\n        public stopAnimation() {\n            if (this._animating) {\n                this._animating=false;\n                this._workDistance=0;\n                this._trainingDistance=0;\n                this._map.un('postcompose', this.tickAnimation);\n                this.showWholeMap();\n            }\n            this._trackIndex=0;\n        }\n\n        public tickAnimation(event) {\n            \n            if (this._animating) {\n                var vectorContext = event.vectorContext;\n                \n                var currentTime = new Date().getTime();\n                var timeSinceLastUpdate : number =0;\n                if (this._lastUpdateTime){\n                    timeSinceLastUpdate = currentTime- this._lastUpdateTime;\n                }\n                var extrapolatedDistance=0;\n                if (this._speed && !this._finished) {\n                    extrapolatedDistance= (this._speed* (timeSinceLastUpdate/1000));\n                }\n                var totalDistanceCalc=this._workDistance+extrapolatedDistance;\n                //take the next track item when moving past the current\n                var currentTrackItem=this._track[this._trackIndex];\n                while (this._trackIndex<this._track.length-1 && totalDistanceCalc>= currentTrackItem.cumualtiveDistance+ currentTrackItem.distance) {\n                    this._trackIndex++;\n                    currentTrackItem=this._track[this._trackIndex];\n                    this._animatedDistance=0.0000001;\n                }\n                var heading=currentTrackItem.heading;\n                //calc the relative positon within the current track line\n                var relativeDistance= totalDistanceCalc - currentTrackItem.cumualtiveDistance;\n                if (relativeDistance<0) //do not go backwards\n                    relativeDistance=0.0000001;\n                //calc the next coordinate\n                var dest = this.calcNextCoordinate(currentTrackItem.latitude, currentTrackItem.longitude, relativeDistance, heading);\n                // calc next coord 2\n                //var dest = this.calcNextCoord2(currentTrackItem.latitude, currentTrackItem.longitude, relativeDistance, heading);\n                \n                if (this._animatedDistance < relativeDistance){ //only update the rower location if there is forward movement\n                    this._animatedDistance = relativeDistance;\n                    var rower_location=ol.proj.fromLonLat([dest.longitude,dest.latitude]);\n                    this._long = dest.longitude;\n                    this._lat = dest.latitude;\n                    var view= this._map.getView();\n                \n                    view.setCenter(rower_location);\n                    view.setRotation(this.calc_rotation(heading))\n\t\t\t\t    //console.log(this._rowingZoom)\n                    var rowerPoint= new ol.geom.Point(rower_location);\n                    this._rower.setGeometry(rowerPoint);\n                }else{\n                    //console.log(this._animatedDistance - relativeDistance)\n                }                \n                //vectorContext.drawFeature(this._rower, this._styles.rower);\n                //var feature = new ol.Feature(rower_location);\n                //vectorContext.drawFeature(feature, this._styles.rower);\n\n                /* \n                console.log({\n                  long :dest.longitude,\n                  lat: dest.latitude,\n                  dist: this._workDistance,\n                  rotation: heading\n                });\n                */\n                this._map.render();\n            }\n            \n        }\n\n        /* Helper functions, courtesy of\n         http://www.movable-type.co.uk/scripts/latlong.html */\n        public calcDistance(lat1 : number, lng1 : number, lat2 : number, lng2 : number) {\n            var a = Math.sin(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180);\n            var b = Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                Math.cos((lng2 - lng1) * Math.PI / 180);\n            return 6371000 * Math.acos(a + b);\n        }\n\n        public calc_rotation(heading) {\n            return (360 - heading) / 360 * Math.PI * 2\n        }\n\n        public radians(n) {\n            return n * (Math.PI / 180);\n        }\n        public degrees(n) {\n            return n * (180 / Math.PI);\n        }\n\n        public calcHeading(startLat,startLong,endLat,endLong){\n            startLat = this.radians(startLat);\n            startLong = this.radians(startLong);\n            endLat = this.radians(endLat);\n            endLong = this.radians(endLong);\n\n            var dLong = endLong - startLong;\n\n            var dPhi = Math.log(Math.tan(endLat/2.0+Math.PI/4.0)/Math.tan(startLat/2.0+Math.PI/4.0));\n            if (Math.abs(dLong) > Math.PI){\n                if (dLong > 0.0)\n                    dLong = -(2.0 * Math.PI - dLong);\n                else\n                    dLong = (2.0 * Math.PI + dLong);\n            }\n\n            return (this.degrees(Math.atan2(dLong, dPhi)) + 360.0) % 360.0;\n        }\n\n\n        public calcNextCoord2(lat1 : number, lon1 : number, dist : number, brng : number) : MapCoordinate {\n            var a = 6378137,\n            b = 6356752.3142,\n            f = 1 / 298.257223563, // WGS-84 ellipsiod\n            s = dist,\n            alpha1 = this.radians(brng),\n            sinAlpha1 = Math.sin(alpha1),\n            cosAlpha1 = Math.cos(alpha1),\n            tanU1 = (1 - f) * Math.tan(this.radians(lat1)),\n            cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1 * cosU1,\n            sigma1 = Math.atan2(tanU1, cosAlpha1),\n            sinAlpha = cosU1 * sinAlpha1,\n            cosSqAlpha = 1 - sinAlpha * sinAlpha,\n            uSq = cosSqAlpha * (a * a - b * b) / (b * b),\n            A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))),\n            B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))),\n            sigma = s / (b * A),\n            sigmaP = 2 * Math.PI;\n            while (Math.abs(sigma - sigmaP) > 1e-12) {\n                var cos2SigmaM = Math.cos(2*sigma1 + sigma),\n                sinSigma = Math.sin(sigma),\n                cosSigma = Math.cos(sigma),\n                deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\n                sigmaP = sigma;\n                sigma = s / (b * A) + deltaSigma;\n            };\n            var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1,\n            lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp)),\n            lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1),\n            C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha)),\n            L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM))),\n            revAz = Math.atan2(sinAlpha, -tmp); // final bearing\n            return {\n                latitude: this.degrees(lat2),\n                longitude: lon1 + this.degrees(L)\n            }\n        }\n\n        public calcNextCoordinate(lat : number, lng : number, dist : number, heading : number) : MapCoordinate {\n            lat *= Math.PI / 180;\n            lng *= Math.PI / 180;\n            heading *= Math.PI / 180;\n            dist /= 6371000; // angular dist\n\n            var lat2 = Math.asin(Math.sin(lat) * Math.cos(dist) +\n                Math.cos(lat) * Math.sin(dist) * Math.cos(heading));\n\n            return {\n                latitude: 180 / Math.PI * lat2,\n                longitude: 180 / Math.PI *\n                (lng + Math.atan2(Math.sin(heading) * Math.sin(dist) * Math.cos(lat2),\n                    Math.cos(dist) - Math.sin(lat) * Math.sin(lat2)))};\n        }\n\n        public initControl() {\n            super.initControl();\n            //make a canvas element within the div of the Erogmeter widget\n            var mapId =this.name+\"Map2d\";\n            this.$container.append(\n                \" <div id='\"+mapId+\"' class='StravaMapContainer'></div>\");\n            this._$map= $(\"#\"+mapId);\n            this.loadMapState();\n            \n            this.initMap();\n            var self=this;\n            \n            this._dialogMapSettings=dialog.newStandardDialog({\n              title: 'Map settings',\n              message: $('#dialogMapStravaSettings'),\n              buttons:[{\n                    label:'Export',\n                    action: (dlg)=>{\n                    this.makeGpxString();\n                    }\n                }],\n              onhide: ()=>{\n                this.updateSettings();\n              }\n            });\n\t\t    $('#mapStravaLoadFile').css(\"visibility\", \"hidden\");\n            $('#mapStravaLoadFileButton').click(function(e) {\n                e.preventDefault();\n                $('#mapStravaLoadFile').trigger('click');\n            });\n\n            //$('#mapStravaExportFileButton').on(\"click\", this.makeGpxString());\n\n            /*\n            var sld = $(\"#MapStravaZoom\").slider()\n                                //.on('slide', this.updateSettings)\n\t\t                        .data('value', this._rowingZoom);\n            */\n\n            $(\"#mapStravaLoadFile\").change(function(evt) {\n            \n                var files = (<any>evt.target).files;\n                for(var i=0;i<files.length;i++){\n                    var file=files[i];\n                    var reader = new FileReader();\n            \n                    reader.onload = function(e) {\n            \n                        try {\n                            self.loadFromKmlData( (<any>e.target).result);\n            \n                        }\n                        catch (err) {\n                            app.showTopError(\"Can not read plugin: \"+err);\n                            throw err;\n                        }\n            \n                       \n            \n            \n                    };\n            \n                    reader.readAsText(file);\n                }\n            \n            });\n            \n        }\n                           \n        public flyTo(locationParm :number[],destZoom: number,heading: number,aboveZoom: number,duration : number,\n                    done : (complete : boolean)=>{}) {\n            var location = ol.proj.fromLonLat(locationParm);\n            \n            var view=this._map.getView();\n            var zoom = view.getZoom();\n            if (!aboveZoom) aboveZoom=zoom;\n            if (!destZoom) destZoom=zoom;\n            \n            var parts = 2;\n            var called = false;\n            function callback(complete) {\n              --parts;\n              if (called) {\n                return;\n              }\n              if (parts === 0 || !complete) {\n                called = true;\n                done(complete);\n              }\n            }\n            view.animate({\n              center: location,\n              duration: duration\n            }, callback);\n            view.animate({\n              zoom: aboveZoom,\n              duration: duration / 2\n            }, {\n              zoom: destZoom,\n              duration: duration / 2,\n              rotation: this.calc_rotation(heading)\n            }, callback);\n        }\n        public showWholeMap() {\n             this._map.getView().fit(this._trackExtent,this._map.getSize()); \n        }\n        public trackLoaded() {\n            this.showWholeMap();\n            this._trackIndex=0;\n            this._animatedDistance=-1;\n            var trackPoint=this._track[this._trackIndex];\n            var rowerPoint= new ol.geom.Point(ol.proj.fromLonLat([trackPoint.longitude,trackPoint.latitude,0]));\n            this._rower.setGeometry(rowerPoint);\n            \n\n        }\n        public setLoadTracEvent() {\n          var self=this;\n          this._raceLayer.once('change', function(evt) {\n              try {\n                  var src=this.getSource();\n                  if (src.getState() == 'ready') {\n                    \n                    var features=src.getFeatures();\n                    if (typeof features === 'undefined' || !features || features.length==0) \n                       throw 'No features in KML file';\n                    var geometry=features[0].getGeometry();\n                    if (typeof geometry === 'undefined' || !geometry || geometry.length==0)\n                      throw 'No geometry found in KML file';\n                    var coordinates=geometry.getCoordinates();\n                    if (typeof coordinates === 'undefined' || !coordinates || coordinates.length==0)\n                      throw 'No coordinates found in KML file';\n                    self._trackExtent=geometry.getExtent();\n                    self._track=[];\n                    var cumualtiveDistance=0;\n                    for (var i=0;i<coordinates.length-2;i++ ) {\n        \n                        var srcCoor =ol.proj.toLonLat(coordinates[i]);\n                        var nextCoor =ol.proj.toLonLat(coordinates[i+1]);\n        \n                        var distance= self.calcDistance(srcCoor[1],srcCoor[0],nextCoor[1],nextCoor[0]);\n        \n                        var heading=self.calcHeading(srcCoor[1],srcCoor[0],nextCoor[1],nextCoor[0]);\n        \n                        self._track.push({\n                            longitude : srcCoor[0],\n                            latitude : srcCoor[1],\n                            distance : distance,\n                            cumualtiveDistance: cumualtiveDistance,\n                            heading: heading\n                        });\n                        cumualtiveDistance += distance; \n                    }\n                    if (self._track.length>0)\n                       self.trackLoaded();\n                  }\n               }\n               catch (e) {\n                   this._kmlData=null;\n                   app.showTopError(e);\n               }\n            });            \n        }\n        public initMap() {\n            \n                    \n           //require([\"https://openlayers.org/en/v3.20.1/build/ol.js\"],\n             //   (ola) => {\n\n               //     ol=ola;\n                    var self = this;\n                    var url='TheBoatRace.kml';\n                    //'http://www.vangulik.org/Ergometer/TheBoatRace.kml'\n                    var projection = ol.proj.get(EPG_MAP);\n                    var mapLayer = new ol.layer.Tile({source: new ol.source.OSM()});\n                    this._styles = {\n                        'rower': new ol.style.Style({\n                          image: new ol.style.Icon({\n                            anchor: [0.5, 0.5],\n                            src: 'images/LogoBW22.png'\n                          })\n                        })}\n                    this._rower = new ol.Feature({\n                        type: 'rower',\n                        geometry: new ol.geom.Point(ol.proj.fromLonLat([-0.212708093427223,51.46670252304421,0]))\n                      });\n                    var rowerLayer = new ol.layer.Vector({\n                        source: new ol.source.Vector({\n                          features: [this._rower]\n                    \n                        }),\n                        style: function(feature) {\n                          // hide geoMarker if animation is active\n                          return self._styles[feature.get('type')];\n                        }\n                      });\n                     \n                    if (this._kmlData) {\n                        this._raceLayer = new ol.layer.Vector();\n                    }\n                    else {\n                      this._mapName='The boat race';\n                      this._raceLayer = new ol.layer.Vector({\n                        source: new ol.source.Vector({\n                          url: url,\n                          format: new ol.format.KML(),\n                    \n                        })\n                      });\n                      \n                    }\n                    this.setLoadTracEvent();\n                    \n                    this._map = new ol.Map({\n                           layers: [mapLayer,this._raceLayer,rowerLayer],\n                            target: this._$map.get(0),\n                            view: new ol.View({\n                              center: ol.proj.fromLonLat([-0.212708093427223,51.46670252304421]),\n                              zoom: 1,\n                              projection: projection\n                              \n                            }),\n                            controls: []\n                        });\n                    if (this._kmlData) {\n       \n                        \n                        this.setRaceLayerFromKmlData();\n\n                        \n                    }\n             //   });\n                    \n\n            \n        }\n\n        public resize() {\n            super.resize();\n\n            this._$map.css({height:(this.$container.innerHeight()-24).toString()+\"px\"});\n            if (this._map) this._map.updateSize();\n\n        }\n\n        public strokeDataUpdate(strokeData : pm3.StrokeData) {\n            //this._workDistance = strokeData.distance + this._lastWorkTime;\n            this._workDistance = strokeData.distance;\n            this._speed=strokeData.speed;\n            this._lastUpdateTime = new Date().getTime();\n            if (!this._finished && this._speed && this._speed>0) {\n                if (!this._animating) {\n                    this.startAnimation();\n                }\n            }\n            else this.stopAnimation();\n\n            // store the locations and time to an array for gpx export\n            //console.log(this._gpxData.length)\n            if (this._long){\n                //console.log([this._long, this._lat, this._lastUpdateTime])\n                this._gpxData.push([this._long, this._lat, this._lastUpdateTime])\n            }\n\n        }\n\n        public trainingDataUpdate(trainingData : pm3.TrainingData) {\n\n            if (this._trainingDistance!=trainingData.distance) {\n                this._trainingDistance=trainingData.distance;\n                //get a new high score for the training distance\n                if (trainingData.distance >0 && this._workDistance==0 && !this._animating)\n                    this.flyToStart( ()=>{});\n\n            }\n            var finished=(trainingData.endDistance>0 && trainingData.endDuration>0);\n            if (finished!=this._finished) {\n                this._finished=finished;\n                if (this._finished) {\n                    this.stopAnimation();\n                    //this._lastWorkTime= this._lastWorkTime+ trainingData.endDistance;\n                }\n            }\n            //this._gpxString = this.makeGpxString()\n\n        }\n\n        public makeGpxString() {\n            \n            let result = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><gpx version=\"1.0\"><name>Example gpx</name><desc>made with js</desc><trk><name>Test Row</name><number>1</number><trkseg>'\n\n            var arrayLength = this._gpxData.length;\n            for (var i = 0; i < arrayLength; i++) {\n                var ts = new Date(this._gpxData[i][2]).toISOString()\n                result += '<trkpt lat=\"' + this._gpxData[i][1] + '\" lon=\"' + this._gpxData[i][0] + '\"><ele>2376</ele><time>' + ts + '</time></trkpt>'\n            }\n            result += '</trkseg></trk></gpx>'\n            var blob;\n            blob = new Blob([result],{\n                type: \"data:text/xml;charset=utf-8\"\n            })\n            utilities.writeFile(blob, \"Workout.GPX\")\n            //return result\n        }\n        \n        public earthInitialized() {\n            console.log(\"Hello\")\n        }\n        public loaded() {\n          super.loaded();\n          pm3.monitor.pubsubs.subStrokeDataUpdate(this, this.strokeDataUpdate);\n          pm3.monitor.pubsubs.subTrainingDataUpdate(this, this.trainingDataUpdate);\n        }\n        public beforeUnload() {\n          super.beforeUnload();\n          pm3.monitor.pubsubs.unsubStrokeDataUpdate(this,this.strokeDataUpdate);\n          pm3.monitor.pubsubs.unsubTrainingDataUpdate(this,this.trainingDataUpdate);\n        }\n\n        constructor (controller : dashboard.Controller) {\n            super(controller);\n            this._trainingDistance=0;\n            this._workDistance=0;\n            this._updateDelay = 1000/20; //20 frames per second\n            this._animating =false;\n            this._waitingForTimeout =false;\n            this._speed=0;\n            this._finished=false;\n            this.caption = \"Map widget example\";\n            this.editPropertiesVisible = true;\n            this.defaultHeight=6;\n            this._track=[];\n            this._gpxData = [];\n        }\n        \n        private setRaceLayerFromKmlData() {\n            var kml = new ol.format.KML();\n            var src=new ol.source.Vector();\n            var features=kml.readFeatures(this._kmlData,{dataProjection:EPG_KML,featureProjection:EPG_MAP  });\n            \n            this._mapName=kml.readName(this._kmlData);\n \n            src.addFeatures(features);\n            this._raceLayer.setSource(src);\n        }\n            \n        public loadFromKmlData(kmlData : string) {\n            \n            this.setLoadTracEvent();\n            this._kmlData=kmlData;\n            this.setRaceLayerFromKmlData(); \n            \n            \n            //var src = this._raceLayer.getSource();\n            //src.clear();\n            //src.addFeatures(features);\n   \n            //this._map.getView().fit(this._raceLayer.getExtent(),this._map.getSize());\n            \n        }\n        public openEditProperties() {\n            $('#stravaMapName').text(this._mapName);\n            $('#stravaMapDistance').text(' ('+this.getTrackDistance().toString()+'m ) ');\n            $('#MapStravaZoomValue').text(this._rowingZoom.toString());\n            $(\"#MapStravaZoom\").val(this._rowingZoom.toString()),\n            $(\"#MapStravaZoom\").slider({\n                value: this._rowingZoom\n            }),\n            this._dialogMapSettings.open();\n        }\n        protected updateSettings() {\n          var newZoom = parseInt( $('#MapStravaZoom').val() );\n          console.log(newZoom)\n          newZoom != this._rowingZoom && (this._rowingZoom = newZoom,\n            this._animating || this.flyToStart(function() {}));\n          this.saveMapState();\n        }\n    \n        protected getMapSettings() : MapSettings {\n            return {kmlData: this._kmlData,\n                    rowingZoom: this._rowingZoom\n            }    \n        }\n        protected setMapSettings(settings : MapSettings) {\n            this._kmlData = settings.kmlData;\n            this._rowingZoom = settings.rowingZoom || 17;\n        }\n        \n        protected saveMapState() {\n            localStorage.setItem(\"MapExampleWidget_settings\",JSON.stringify(this.getMapSettings() ));\n        }\n        protected loadMapState() {\n            var settingsString=localStorage.getItem(\"MapExampleWidget_settings\");\n            var settings : MapSettings;\n            if  (settingsString!=\"undefined\" && settingsString!=null && settingsString!=\"null\"  ) {\n                settings=<MapSettings> JSON.parse(settingsString);\n                this.setMapSettings(settings);\n            }\n        }\n        protected getTrackDistance() : number {\n            if ( this._track && this._track.length>0)\n               return Math.round(this._track[this._track.length-1].cumualtiveDistance);\n            else return 0;\n        }\n\n\n    }\n    /*------------------------------------------------------------------------------\n     Create and remove the widgets in the Plugin\n     ------------------------------------------------------------------------------*/\n    class StravaPlugin extends ExternalPlugin {\n\n        public mapsWidget : MapWidgetStrava;\n\n\n        public init() {\n            //create the widget(s) on create\n            dashboard.widgetRegistry().register(MapWidgetStrava,'odm7341_MapWidgetStrava','Strava Map',['Other']);\n        }\n        public remove() {\n            //remove the widgets when the plugin is removed\n            dashboard.widgetRegistry().deregister('odm7341_MapWidgetStrava');\n        }\n    }\n\n    var plugin : StravaPlugin;\n    plugin = new StravaPlugin();\n\n}\n","html":"<div style=\"display:none;height=0\">\r\n<div id=\"dialogMapStravaSettings\" title=\"Strava map settings\" >\r\n        <div class=\"control-group\">\r\n           <label class=\"control-label\" >Route</label>\r\n            <div class=\"controls\" for=\"mapStravaLoadFileButton\">\r\n               <span id=\"stravaMapName\" ></span>\r\n               <span id=\"stravaMapDistance\" ></span>\r\n               <button id=\"mapStravaLoadFileButton\" class=\"btn btn-default\" >Load from KML file</button><input type=\"file\" id=\"mapStravaLoadFile\" >\r\n            <p class=\"help-block\" >Kml files contain a route can be created using google maps or google earth</p>\r\n            </div>\r\n        </div>\r\n        <!---\r\n        <div class=\"control-group\">\r\n            <div class=\"controls\" for=\"mapStravaExportFileButton\">\r\n               <button id=\"mapStravaExportFileButton\" class=\"btn btn-default\" >Export .GPX for Strava</button>\r\n            </div>\r\n        </div>\r\n        --->\r\n    <div class=\"control-group\">\r\n        <label class=\"control-label\" for=\"MapStravaZoom\">Rowing zoom</label>\r\n    \r\n        <div class=\"controls\" >\r\n            <div id=\"MapStravaZoomValue\" ></div>\r\n            <input id=\"MapStravaZoom\" data-slider-id='MapStravaZoomSlider' data-slider-min=\"8\" data-slider-max=\"25\" data-slider-step=\"1\" data-slider-value=\"14\"/>\r\n        </div>\r\n    \r\n    </div>\r\n\r\n</div>\r\n</div>"}